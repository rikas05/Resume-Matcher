# -*- coding: utf-8 -*-
"""resume_matcher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xBgP7PfxGK-Kb2KSfOMmay0jeNbAwRMa
"""



import os
import re
import numpy as np
from typing import List, Dict, Tuple
from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
from scipy.stats import percentileofscore
import PyPDF2

try:
    from pypdf import PdfReader
    print("Using pypdf library")
except ImportError:
    try:
        from PyPDF2 import PdfReader
        print("Using PyPDF2 library")
    except ImportError:
        raise ImportError("Please install PDF library: !pip install pypdf")

class ResumeMatcherAI:
    """
    AI-powered resume matcher using Sentence-BERT embeddings and cosine similarity.
    Compatible with both pypdf and PyPDF2 libraries.
    """
    # Define PDF_LIBRARY here
    PDF_LIBRARY = "PyPDF2" # Or "pypdf" if you prefer

    def __init__(self, model_name: str = 'all-MiniLM-L6-v2'):
        """
        Initialize the resume matcher with specified Sentence-BERT model.

        Args:
            model_name (str): Name of the Sentence-BERT model to use
        """
        print(f"Using PDF library: {self.PDF_LIBRARY}")
        print(f"Loading Sentence-BERT model: {model_name}")
        self.model = SentenceTransformer(model_name)
        print("Model loaded successfully!")

    def clean_text(self, text: str) -> str:
        """
        Preprocess text by cleaning and normalizing.

        Args:
            text (str): Raw text to be cleaned

        Returns:
            str: Cleaned and preprocessed text
        """
        if not text:
            return ""

        # Convert to lowercase
        text = text.lower()

        # Remove HTML tags
        text = re.sub(r'<[^>]+>', '', text)

        # Remove URLs
        text = re.sub(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', '', text)

        # Remove punctuation (keep spaces and alphanumeric)
        text = re.sub(r'[^\w\s]', ' ', text)

        # Remove extra whitespace
        text = re.sub(r'\s+', ' ', text).strip()

        return text

    def extract_text_from_pdf(self, pdf_path: str) -> str:
        """
        Extract plain text content from a PDF file.
        Compatible with both pypdf and PyPDF2.

        Args:
            pdf_path (str): Path to the PDF file

        Returns:
            str: Extracted text content
        """
        try:
            with open(pdf_path, 'rb') as file:
                if self.PDF_LIBRARY == "PyPDF2":
                    pdf_reader = PyPDF2.PdfReader(file)
                elif self.PDF_LIBRARY == "pypdf":
                     from pypdf import PdfReader # Import pypdf here if needed
                     pdf_reader = PdfReader(file)
                else:
                    raise ValueError(f"Unsupported PDF library: {self.PDF_LIBRARY}")

                text = ""

                # Extract text from all pages
                for page_num in range(len(pdf_reader.pages)):
                    page = pdf_reader.pages[page_num]
                    text += page.extract_text()

                return text

        except Exception as e:
            print(f"Error reading PDF {pdf_path}: {str(e)}")
            return ""

    def generate_embeddings(self, text_list: List[str]) -> np.ndarray:
        """
        Generate Sentence-BERT embeddings for a list of texts.

        Args:
            text_list (List[str]): List of texts to embed

        Returns:
            np.ndarray: Array of embeddings
        """
        print(f"Generating embeddings for {len(text_list)} texts...")
        embeddings = self.model.encode(text_list, convert_to_tensor=False)
        return embeddings

    def calculate_similarity(self, resume_embeddings: np.ndarray, job_embedding: np.ndarray) -> np.ndarray:
        """
        Calculate cosine similarity between resume embeddings and job description embedding.

        Args:
            resume_embeddings (np.ndarray): Array of resume embeddings
            job_embedding (np.ndarray): Job description embedding

        Returns:
            np.ndarray: Array of similarity scores
        """
        # Reshape job_embedding to 2D array for cosine_similarity
        job_embedding = job_embedding.reshape(1, -1)

        # Calculate cosine similarity
        similarities = cosine_similarity(resume_embeddings, job_embedding)

        # Return flattened array of similarities
        return similarities.flatten()

    def calculate_percentile(self, similarity_scores: np.ndarray) -> np.ndarray:
        """
        Calculate percentile ranking for each similarity score.

        Args:
            similarity_scores (np.ndarray): Array of similarity scores

        Returns:
            np.ndarray: Array of percentile rankings
        """
        percentiles = np.array([
            percentileofscore(similarity_scores, score, kind='rank')
            for score in similarity_scores
        ])
        return percentiles

    def load_resumes_from_folder(self, folder_path: str) -> Tuple[List[str], List[str]]:
        """
        Load all PDF resumes from a specified folder.

        Args:
            folder_path (str): Path to folder containing resume PDFs

        Returns:
            Tuple[List[str], List[str]]: Lists of resume texts and filenames
        """
        if not os.path.exists(folder_path):
            raise FileNotFoundError(f"Folder not found: {folder_path}")

        resume_texts = []
        filenames = []

        # Get all PDF files in the folder
        pdf_files = [f for f in os.listdir(folder_path) if f.lower().endswith('.pdf')]

        if not pdf_files:
            raise ValueError(f"No PDF files found in {folder_path}")

        print(f"Found {len(pdf_files)} PDF files. Extracting text...")

        for filename in pdf_files:
            pdf_path = os.path.join(folder_path, filename)
            text = self.extract_text_from_pdf(pdf_path)

            if text.strip():  # Only add non-empty texts
                cleaned_text = self.clean_text(text)
                resume_texts.append(cleaned_text)
                filenames.append(filename)
            else:
                print(f"Warning: Could not extract text from {filename}")

        return resume_texts, filenames

    def get_job_description(self) -> str:
        """
        Get job description from user input (manual entry or PDF file).

        Returns:
            str: Cleaned job description text
        """
        print("\n=== Job Description Input ===")
        print("Choose an option:")
        print("1. Type job description manually")
        print("2. Load from job_description.pdf file")

        while True:
            choice = input("\nEnter your choice (1 or 2): ").strip()

            if choice == '1':
                print("\nPlease enter the job description (press Enter twice to finish):")
                lines = []
                while True:
                    line = input()
                    if line == "" and len(lines) > 0:
                        break
                    lines.append(line)

                job_description = "\n".join(lines)
                return self.clean_text(job_description)

            elif choice == '2':
                pdf_path = "job_description.pdf"
                if not os.path.exists(pdf_path):
                    print(f"Error: {pdf_path} not found!")
                    continue

                text = self.extract_text_from_pdf(pdf_path)
                if not text.strip():
                    print("Error: Could not extract text from job_description.pdf")
                    continue

                return self.clean_text(text)

            else:
                print("Invalid choice. Please enter 1 or 2.")

    def get_shortlisting_criteria(self) -> Tuple[float, float]:
        """
        Get shortlisting criteria from recruiter input.

        Returns:
            Tuple[float, float]: Minimum match score and percentile thresholds
        """
        print("\n=== Shortlisting Criteria ===")
        print("Set minimum thresholds for shortlisting candidates:")

        # Get minimum match score
        while True:
            try:
                min_match_score = input("\nEnter minimum match score percentage (0-100, or press Enter for no filter): ").strip()
                if min_match_score == "":
                    min_match_score = 0.0
                    break
                else:
                    min_match_score = float(min_match_score)
                    if 0 <= min_match_score <= 100:
                        break
                    else:
                        print("Please enter a value between 0 and 100.")
            except ValueError:
                print("Please enter a valid number.")

        # Get minimum percentile
        while True:
            try:
                min_percentile = input("Enter minimum percentile ranking (0-100, or press Enter for no filter): ").strip()
                if min_percentile == "":
                    min_percentile = 0.0
                    break
                else:
                    min_percentile = float(min_percentile)
                    if 0 <= min_percentile <= 100:
                        break
                    else:
                        print("Please enter a value between 0 and 100.")
            except ValueError:
                print("Please enter a valid number.")

        return min_match_score, min_percentile

    def apply_shortlisting_filters(self, results: List[Dict], min_match_score: float, min_percentile: float) -> List[Dict]:
        """
        Apply shortlisting filters based on minimum thresholds.

        Args:
            results (List[Dict]): List of all match results
            min_match_score (float): Minimum match score threshold
            min_percentile (float): Minimum percentile threshold

        Returns:
            List[Dict]: Filtered list of shortlisted candidates
        """
        shortlisted = []

        for result in results:
            # Check if candidate meets both criteria
            if (result['match_score'] >= min_match_score and
                result['percentile_rank'] >= min_percentile):
                shortlisted.append(result)

        return shortlisted

    def match_resumes(self, resumes_folder: str = "resumes") -> Tuple[List[Dict], List[Dict], float, float]:
        """
        Main function to match resumes against job description.

        Args:
            resumes_folder (str): Path to folder containing resume PDFs

        Returns:
            Tuple[List[Dict], List[Dict], float, float]: All results, shortlisted results, and thresholds
        """
        try:
            # Load resumes from folder
            print(f"\n=== Loading Resumes from {resumes_folder}/ ===")
            resume_texts, filenames = self.load_resumes_from_folder(resumes_folder)

            if not resume_texts:
                raise ValueError("No valid resume texts found!")

            # Get job description
            job_description = self.get_job_description()

            if not job_description.strip():
                raise ValueError("Job description is empty!")

            # Generate embeddings
            print(f"\n=== Processing {len(resume_texts)} resumes ===")

            # Combine all texts for batch embedding generation
            all_texts = resume_texts + [job_description]
            all_embeddings = self.generate_embeddings(all_texts)

            # Split embeddings
            resume_embeddings = all_embeddings[:-1]  # All except last
            job_embedding = all_embeddings[-1]       # Last embedding

            # Calculate similarities
            print("Calculating similarity scores...")
            similarities = self.calculate_similarity(resume_embeddings, job_embedding)

            # Calculate percentiles
            print("Calculating percentile rankings...")
            percentiles = self.calculate_percentile(similarities)

            # Prepare results
            results = []
            for i, filename in enumerate(filenames):
                result = {
                    'filename': filename,
                    'match_score': round(similarities[i] * 100, 2),  # Convert to percentage
                    'percentile_rank': round(percentiles[i], 1)
                }
                results.append(result)

            # Sort by match score (descending)
            results.sort(key=lambda x: x['match_score'], reverse=True)

            # Get shortlisting criteria from recruiter
            min_match_score, min_percentile = self.get_shortlisting_criteria()

            # Apply shortlisting filters
            shortlisted = self.apply_shortlisting_filters(results, min_match_score, min_percentile)

            print("DEBUG: Finished match_resumes call")
            return results, shortlisted, min_match_score, min_percentile

        except Exception as e:
            print(f"Error during matching: {str(e)}")
            return [], [], 0.0, 0.0

    def display_results(self, results: List[Dict], shortlisted: List[Dict] = None,
                       min_match_score: float = 0.0, min_percentile: float = 0.0) -> None:
        """
        Display the matching results in a formatted table.

        Args:
            results (List[Dict]): List of all match results
            shortlisted (List[Dict], optional): List of shortlisted candidates
            min_match_score (float): Minimum match score threshold used
            min_percentile (float): Minimum percentile threshold used
        """
        if not results:
            print("No results to display.")
            return

        print("\n" + "="*80)
        print("RESUME MATCHING RESULTS")
        print("="*80)
        print(f"{'Rank':<6} {'Filename':<30} {'Match Score':<12} {'Percentile':<10} {'Status':<12}")
        print("-"*80)

        for i, result in enumerate(results, 1):
            # Determine if candidate is shortlisted
            if shortlisted and result in shortlisted:
                status = "SHORTLISTED"
            elif shortlisted is not None:
                status = "FILTERED OUT"
            else:
                status = "ALL RESULTS"

            print(f"{i:<6} {result['filename']:<30} {result['match_score']:<12}% {result['percentile_rank']:<10}% {status:<12}")

        print("-"*80)
        print(f"Total resumes processed: {len(results)}")

        if shortlisted is not None:
            print(f"Shortlisted candidates: {len(shortlisted)}")
            print(f"Filter criteria - Min Match Score: {min_match_score}%, Min Percentile: {min_percentile}%")

            if shortlisted:
                print(f"Best shortlisted match: {shortlisted[0]['filename']} ({shortlisted[0]['match_score']}%)")
            else:
                print("No candidates met the shortlisting criteria.")
        else:
            print(f"Best match: {results[0]['filename']} ({results[0]['match_score']}%)")


def export_shortlisted_candidates(shortlisted: List[Dict]) -> None:
    """
    Export shortlisted candidates to a text file.

    Args:
        shortlisted (List[Dict]): List of shortlisted candidates
    """
    try:
        filename = "shortlisted_candidates.txt"
        with open(filename, 'w') as f:
            f.write("SHORTLISTED CANDIDATES\n")
            f.write("="*50 + "\n\n")

            for i, candidate in enumerate(shortlisted, 1):
                f.write(f"{i}. {candidate['filename']}\n")
                f.write(f"   Match Score: {candidate['match_score']}%\n")
                f.write(f"   Percentile Rank: {candidate['percentile_rank']}%\n\n")

        print(f"Shortlisted candidates exported to {filename}")

    except Exception as e:
        print(f"Error exporting candidates: {str(e)}")


def main():
    """
    Main function to run the resume matcher.
    """
    print("AI-Powered Resume Matcher")
    print("="*50)

    # Initialize the matcher
    matcher = ResumeMatcherAI()

    # Run the matching process
    results, shortlisted, min_match_score, min_percentile = matcher.match_resumes()

    # Display results
    matcher.display_results(results, shortlisted, min_match_score, min_percentile)

    # Export shortlisted candidates option
    if shortlisted:
        print(f"\n=== Export Options ===")
        export_choice = input("Would you like to export shortlisted candidates? (y/n): ").strip().lower()

        if export_choice == 'y':
            export_shortlisted_candidates(shortlisted)


if __name__ == "__main__":
    main()

